/*
 * overlay_startup.c
 *
 *  Created on: Apr 5, 2024
 *      Author: micahbly
 *
 *  Routines for starting up Infestation!, including initializing graphics/sprites
 *    Some code here originated in sys.c and other places before being moved here
 *
 */



/*****************************************************************************/
/*                                Includes                                   */
/*****************************************************************************/

// project includes
#include "overlay_startup.h"
#include "app.h"
#include "comm_buffer.h"
#include "general.h"
#include "kernel.h"
#include "keyboard.h"
#include "level.h"
#include "memory.h"
#include "object.h"
#include "player.h"
#include "sys.h"
#include "text.h"
#include "strings.h"

// C includes
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// F256 includes
#include "f256.h"




/*****************************************************************************/
/*                               Definitions                                 */
/*****************************************************************************/

#define UI_BYTE_SIZE_OF_LOGO				(36*45)		// firebird logo size.
#define UI_BYTE_SIZE_OF_MACHINE_LOGO		(63*7)		// 441b = size of "F256JR" & "F256K" chars + colors (each)
#define UI_BYTE_SIZE_OF_MACHINE_LOGO_LEFT	287
#define UI_BYTE_SIZE_OF_MACHINE_LOGO_RIGHT	140

#define MACHINE_SPLASH_NUM_ROWS			7
#define MACHINE_SPLASH_START_ROW		1	//27
#define MACHINE_SPLASH_BOTTOM_ROW		(MACHINE_SPLASH_START_ROW + 6)
#define MACHINE_SPLASH_TRAVEL_ROWS		(MACHINE_SPLASH_START_ROW - 0)
#define MACHINE_SPLASH_H_SLIDE_DIST		17	// the number of cols that the JR or K extension needs to move in from off-screen right to be lined up behind the F256 chars.

#define MACHINE_SPLASH_WIDTH_LEFT		40
#define MACHINE_SPLASH_START_COL_LEFT	19
#define MACHINE_SPLASH_END_COL_LEFT		(MACHINE_SPLASH_START_COL_LEFT + MACHINE_SPLASH_WIDTH_LEFT)
#define MACHINE_SPLASH_JR_OFFSET		5	// K is 10 chars fewer than JR, so start logo for JR machines 5 chars to left of K start spot (centered)

#define MACHINE_SPLASH_WIDTH_RIGHT		20
#define MACHINE_SPLASH_START_COL_RIGHT	(MACHINE_SPLASH_END_COL_LEFT + 2)
#define MACHINE_SPLASH_END_COL_RIGHT	(MACHINE_SPLASH_START_COL_RIGHT + MACHINE_SPLASH_WIDTH_RIGHT)	// note: this is one too many, but I like the effect :) 


#define LOGO_START_ROW					10
#define LOGO_BOTTOM_ROW					(LOGO_START_ROW + 44)

#define LOGO_WIDTH						36
#define LOGO_START_COL					22
#define LOGO_END_COL					(LOGO_START_COL + (LOGO_WIDTH - 1))

#define INFO_MACHINE_DISPLAY_ROW		56
#define INFO_KERNEL_DISPLAY_ROW			(INFO_MACHINE_DISPLAY_ROW + 1)
#define INFO_FMANAGER_DISPLAY_ROW		(INFO_KERNEL_DISPLAY_ROW + 1)
#define INFO_SUPERBASIC_DISPLAY_ROW		(INFO_FMANAGER_DISPLAY_ROW + 1)




/*****************************************************************************/
/*                           File-scope Variables                            */
/*****************************************************************************/

// rest of data here we want to store in this overlay

#pragma data-name ("OVERLAY_STARTUP")

static uint8_t custom_font_data[2048] = 
{
0x0F,0x19,0x18,0x7C, 0x38,0x38,0x7F,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0xFF,0xFF, 0x00,0x00,0x00,0x00, 0x00,0xFF,0xFF,0xFF, 0x00,0x00,0x00,0x00, 0xFF,0xFF,0xFF,0xFF, 0x00,0x00,0x00,0xFF, 0xFF,0xFF,0xFF,0xFF, 0x00,0x00,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0x00,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0xFF,0x00, 0xFF,0xFF,0xFF,0xFF, 0xFF,0xFF,0x00,0x00, 0xFF,0xFF,0xFF,0xFF, 0xFF,0x00,0x00,0x00, 0xFF,0xFF,0xFF,0xFF, 0x00,0x00,0x00,0x00, 0xFF,0xFF,0xFF,0x00, 0x00,0x00,0x00,0x00, 0xFF,0xFF,0x00,0x00, 0x00,0x00,0x00,0x00, 0xFF,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x08,0x00,0x22,0x00, 0x08,0x00,0x02,0x00, 0x88,0x00,0x22,0x00, 0x88,0x00,0x22,0x00, 0x8A,0x00,0x2A,0x00, 0x8A,0x00,0x2A,0x00, 0xAA,0x00,0xAA,0x00, 0xAA,0x00,0xAA,0x00, 0xAA,0x05,0xAA,0x11, 0xAA,0x05,0xAA,0x11, 0xAA,0x5F,0xAA,0x77, 0xAA,0x5F,0xAA,0x77, 0xAA,0xFF,0xAA,0xFF, 0xAA,0xFF,0xAA,0xFF, 0xAF,0xFF,0xBB,0xFF, 0xAF,0xFF,0xBB,0xFF, 0x77,0xFF,0xDD,0xFF, 0x77,0xFF,0xDD,0xFF, 0x7F,0xFF,0xDF,0xFF, 0x77,0xFF,0xDF,0xFF, 0xFF,0xFF,0xDF,0xFF, 0x77,0xFF,0xDD,0xFF, 0xBB,0xFF,0xEE,0xFF, 0xAA,0xFF,0xAA,0xFF, 0xAA,0xFF,0xAA,0x77, 0xAA,0xDD,0xAA,0x55, 0xAA,0x55,0x22,0x55, 0x88,0x55,0x00,0x55, 0xAA,0x00,0xAA,0x00, 0x88,0x00,0x22,0x00, 0x33,0x99,0xCC,0x66, 0x33,0x99,0xCC,0x66, 0xCC,0x99,0x33,0x66, 0xCC,0x99,0x33,0x66, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x30,0x30,0x30,0x38, 0x38,0x00,0x38,0x00, 0xEE,0xEE,0xEE,0x00, 0x00,0x00,0x00,0x00, 0x66,0x66,0xFF,0x66, 0xFF,0x66,0x66,0x00, 0x18,0xFE,0xC0,0xFE, 0x0E,0xFE,0x38,0x00, 0xE2,0xE6,0x0C,0x18, 0x30,0x6E,0x4E,0x00, 0x7E,0x66,0x7E,0x3C, 0x67,0x66,0x7F,0x00, 0x1C,0x1C,0x38,0x00, 0x00,0x00,0x00,0x00, 0x0C,0x18,0x30,0x30, 0x38,0x1C,0x0E,0x00, 0x30,0x18,0x0C,0x0C, 0x1C,0x38,0x70,0x00, 0x10,0x54,0x38,0xFE, 0x38,0x54,0x10,0x00, 0x00,0x30,0x30,0xFC, 0x30,0x30,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x38,0x38,0x70, 0x00,0x00,0x00,0xFE, 0xF0,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x38,0x38,0x00, 0x00,0x06,0x0C,0x18, 0x38,0x70,0xE0,0x00, 0xFE,0xC6,0xCE,0xD6, 0xE6,0xE6,0xFE,0x00, 0x18,0x38,0x18,0x18, 0x1C,0x1C,0x7E,0x00, 0xFE,0x06,0x06,0xFE, 0xE0,0xE0,0xFE,0x00, 0xFE,0x06,0x06,0x3E, 0x0E,0x0E,0xFE,0x00, 0xC6,0xC6,0xC6,0xFE, 0x0E,0x0E,0x0E,0x00, 0xFE,0xC0,0xC0,0xFE, 0x0E,0x0E,0xFE,0x00, 0xFE,0xC0,0xC0,0xFE, 0xE6,0xE6,0xFE,0x00, 0xFE,0x06,0x0C,0x18, 0x1C,0x1C,0x1C,0x00, 0x7E,0x66,0x66,0xFE, 0xE6,0xE6,0xFE,0x00, 0xFE,0xC6,0xC6,0xFE, 0x0E,0x0E,0xFE,0x00, 0x00,0x70,0x70,0x00, 0x70,0x70,0x00,0x00, 0x00,0x70,0x70,0x00, 0x70,0x70,0xE0,0x00, 0x0C,0x18,0x30,0x70, 0x38,0x1C,0x0E,0x00, 0x00,0x00,0xFE,0x00, 0xFE,0x00,0x00,0x00, 0x30,0x18,0x0C,0x0E, 0x1C,0x38,0x70,0x00, 0xFE,0xC6,0x06,0x1C, 0x38,0x00,0x38,0x00, 0x7C,0xC2,0xDE,0xD2, 0xFE,0xE0,0x7C,0x00, 0xFE,0xC6,0xC6,0xFE, 0xE6,0xE6,0xE6,0x00, 0xFC,0xCC,0xCC,0xFE, 0xE6,0xE6,0xFE,0x00, 0xFE,0xC0,0xC0,0xC0, 0xE0,0xE0,0xFE,0x00, 0xFC,0xC6,0xC6,0xC6, 0xE6,0xE6,0xFC,0x00, 0xFE,0xC0,0xC0,0xF8, 0xE0,0xE0,0xFE,0x00, 0xFE,0xC0,0xC0,0xF8, 0xE0,0xE0,0xE0,0x00, 0xFE,0xC0,0xC0,0xCE, 0xE6,0xE6,0xFE,0x00, 0xC6,0xC6,0xC6,0xFE, 0xE6,0xE6,0xE6,0x00, 0x78,0x30,0x30,0x30, 0x38,0x38,0x7C,0x00, 0x1E,0x0C,0x0C,0x0C, 0xCE,0xCE,0xFE,0x00, 0xC6,0xC6,0xCC,0xF8, 0xEC,0xE6,0xE6,0x00, 0xC0,0xC0,0xC0,0xE0, 0xE0,0xE0,0xFE,0x00, 0xFE,0xD6,0xD6,0xC6, 0xE6,0xE6,0xE6,0x00, 0xE6,0xF6,0xDE,0xCE, 0xE6,0xE6,0xE6,0x00, 0xFE,0xC6,0xC6,0xC6, 0xE6,0xE6,0xFE,0x00, 0xFE,0xC6,0xC6,0xFE, 0xE0,0xE0,0xE0,0x00, 0xFE,0xC6,0xC6,0xE6, 0xE6,0xFE,0x0E,0x00, 0xFE,0xC6,0xC6,0xFE, 0xF8,0xEC,0xE6,0x00, 0xFE,0xC6,0xC0,0xFE, 0x0E,0xCE,0xFE,0x00, 0xFE,0x30,0x30,0x30, 0x38,0x38,0x38,0x00, 0xC6,0xC6,0xC6,0xC6, 0xE6,0xE6,0xFE,0x00, 0xC6,0xC6,0xC6,0xE6, 0xE6,0x7C,0x38,0x00, 0xE6,0xE6,0xC6,0xD6, 0xD6,0xD6,0xFE,0x00, 0xC6,0xC6,0xC6,0x38, 0xE6,0xE6,0xE6,0x00, 0xC6,0xC6,0xE6,0xE6, 0x38,0x38,0x38,0x00, 0xFE,0x06,0x0C,0x18, 0x70,0xE0,0xFE,0x00, 0x3E,0x30,0x30,0x38, 0x38,0x38,0x3E,0x00, 0x00,0xC0,0x60,0x30, 0x38,0x1C,0x0E,0x00, 0x7C,0x0C,0x0C,0x1C, 0x1C,0x1C,0x7C,0x00, 0x00,0x18,0x3C,0x66, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0xFF, 0x38,0x38,0x1C,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0xFE,0x06, 0xFE,0xE6,0xFE,0x00, 0xC0,0xC0,0xFE,0xC6, 0xE6,0xE6,0xFE,0x00, 0x00,0x00,0xFE,0xC0, 0xE0,0xE0,0xFE,0x00, 0x06,0x06,0xFE,0xC6, 0xE6,0xE6,0xFE,0x00, 0x00,0x00,0xFE,0xC6, 0xFE,0xE0,0xFE,0x00, 0x3E,0x30,0x30,0xFC, 0x38,0x38,0x38,0x00, 0x00,0x00,0xFE,0xC6, 0xCE,0xFE,0x0E,0xFE, 0xC0,0xC0,0xFE,0xC6, 0xE6,0xE6,0xE6,0x00, 0x00,0x30,0x00,0x30, 0x38,0x38,0x38,0x00, 0x00,0x0C,0x00,0x0C, 0x0C,0x0E,0xCE,0xFE, 0xC0,0xC0,0xC6,0xF8, 0xF8,0xE6,0xE6,0x00, 0x30,0x30,0x30,0x30, 0x38,0x38,0x38,0x00, 0x00,0x00,0xFE,0xD6, 0xD6,0xE6,0xE6,0x00, 0x00,0x00,0xFE,0xC6, 0xE6,0xE6,0xE6,0x00, 0x00,0x00,0xFE,0xC6, 0xE6,0xE6,0xFE,0x00, 0x00,0x00,0xFE,0xC6, 0xE6,0xFE,0xE0,0xE0, 0x00,0x00,0xFE,0xC6, 0xCE,0xFE,0x0E,0x0E, 0x00,0x00,0xFE,0xC6, 0xE0,0xE0,0xE0,0x00, 0x00,0x00,0xFE,0xC0, 0xFE,0x0E,0xFE,0x00, 0x30,0x30,0xFC,0x38, 0x38,0x38,0x3E,0x00, 0x00,0x00,0xC6,0xC6, 0xE6,0xE6,0xFE,0x00, 0x00,0x00,0xC6,0xC6, 0xE6,0xEC,0x78,0x00, 0x00,0x00,0xE6,0xE6, 0xD6,0xD6,0xFE,0x00, 0x00,0x00,0xC6,0xC6, 0x38,0xE6,0xE6,0x00, 0x00,0x00,0xC6,0xE6, 0xE6,0xFE,0x06,0xFE, 0x00,0x00,0xFE,0x0C, 0x38,0x70,0xFE,0x00, 0x1C,0x10,0x10,0x70, 0x30,0x30,0x3C,0x00, 0x10,0x10,0x10,0x10, 0x18,0x18,0x18,0x00, 0x38,0x08,0x08,0x0E, 0x0C,0x0C,0x3C,0x00, 0x00,0x00,0x30,0x49, 0x06,0x00,0x00,0x00, 0x08,0x04,0x04,0x08, 0x10,0x10,0x08,0x00, 0x02,0x02,0x02,0x02, 0x02,0x02,0x02,0x02, 0x04,0x04,0x04,0x04, 0x04,0x04,0x04,0x04, 0x08,0x08,0x08,0x08, 0x08,0x08,0x08,0x08, 0x10,0x10,0x10,0x10, 0x10,0x10,0x10,0x10, 0x20,0x20,0x20,0x20, 0x20,0x20,0x20,0x20, 0x40,0x40,0x40,0x40, 0x40,0x40,0x40,0x40, 0x80,0x80,0x80,0x80, 0x80,0x80,0x80,0x80, 0xC0,0xC0,0xC0,0xC0, 0xC0,0xC0,0xC0,0xC0, 0xE0,0xE0,0xE0,0xE0, 0xE0,0xE0,0xE0,0xE0, 0xF0,0xF0,0xF0,0xF0, 0xF0,0xF0,0xF0,0xF0, 0xF8,0xF8,0xF8,0xF8, 0xF8,0xF8,0xF8,0xF8, 0xFC,0xFC,0xFC,0xFC, 0xFC,0xFC,0xFC,0xFC, 0xFE,0xFE,0xFE,0xFE, 0xFE,0xFE,0xFE,0xFE, 0x7F,0x7F,0x7F,0x7F, 0x7F,0x7F,0x7F,0x7F, 0x3F,0x3F,0x3F,0x3F, 0x3F,0x3F,0x3F,0x3F, 0x1F,0x1F,0x1F,0x1F, 0x1F,0x1F,0x1F,0x1F, 0x0F,0x0F,0x0F,0x0F, 0x0F,0x0F,0x0F,0x0F, 0x07,0x07,0x07,0x07, 0x07,0x07,0x07,0x07, 0x03,0x03,0x03,0x03, 0x03,0x03,0x03,0x03, 0x01,0x01,0x01,0x01, 0x01,0x01,0x01,0x01, 0x00,0x00,0x00,0x00, 0x00,0x00,0xFF,0x00, 0x00,0x00,0x00,0x00, 0x00,0xFF,0x00,0x00, 0x00,0x00,0x00,0x00, 0xFF,0x00,0x00,0x00, 0x00,0x00,0x00,0xFF, 0x00,0x00,0x00,0x00, 0x00,0x00,0xFF,0x00, 0x00,0x00,0x00,0x00, 0x00,0xFF,0x00,0x00, 0x00,0x00,0x00,0x00, 0x08,0x08,0x08,0x08, 0x0F,0x08,0x08,0x08, 0x00,0x00,0x00,0x00, 0xFF,0x08,0x08,0x08, 0x08,0x08,0x08,0x08, 0xFF,0x08,0x08,0x08, 0x08,0x08,0x08,0x08, 0xFF,0x00,0x00,0x00, 0x08,0x08,0x08,0x08, 0xF8,0x08,0x08,0x08, 0x81,0x42,0x24,0x18, 0x18,0x24,0x42,0x81, 0x00,0x00,0x00,0x00, 0x0F,0x08,0x08,0x08, 0x00,0x00,0x00,0x00, 0xF8,0x08,0x08,0x08, 0x08,0x08,0x08,0x08, 0x0F,0x00,0x00,0x00, 0x08,0x08,0x08,0x08, 0xF8,0x00,0x00,0x00, 0x18,0x18,0x18,0x1F, 0x1F,0x18,0x18,0x18, 0x00,0x00,0x00,0xFF, 0xFF,0x18,0x18,0x18, 0x18,0x18,0x18,0xFF, 0xFF,0x18,0x18,0x18, 0x18,0x18,0x18,0xFF, 0xFF,0x00,0x00,0x00, 0x18,0x18,0x18,0xF8, 0xF8,0x18,0x18,0x18, 0x00,0x00,0x00,0x1F, 0x1F,0x18,0x18,0x18, 0x00,0x00,0x00,0xF8, 0xF8,0x18,0x18,0x18, 0x18,0x18,0x18,0x1F, 0x1F,0x00,0x00,0x00, 0x18,0x18,0x18,0xF8, 0xF8,0x00,0x00,0x00, 0x00,0x00,0x00,0xFF, 0xFF,0x00,0x00,0x00, 0x18,0x18,0x18,0x18, 0x18,0x18,0x18,0x18, 0x00,0x00,0x00,0x00, 0x03,0x07,0x0F,0x0F, 0x00,0x00,0x00,0x00, 0xC0,0xE0,0xF0,0xF0, 0x0F,0x0F,0x07,0x03, 0x00,0x00,0x00,0x00, 0xF0,0xF0,0xE0,0xC0, 0x00,0x00,0x00,0x00, 0x00,0x3C,0x42,0x42, 0x42,0x42,0x3C,0x00, 0x00,0x3C,0x7E,0x7E, 0x7E,0x7E,0x3C,0x00, 0x00,0x7E,0x7E,0x7E, 0x7E,0x7E,0x7E,0x00, 0x00,0x00,0x00,0x18, 0x18,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x08,0x00,0x00,0x00, 0xFF,0x7F,0x3F,0x1F, 0x0F,0x07,0x03,0x01, 0xFF,0xFE,0xFC,0xF8, 0xF0,0xE0,0xC0,0x80, 0x80,0x40,0x20,0x10, 0x08,0x04,0x02,0x01, 0x01,0x02,0x04,0x08, 0x10,0x20,0x40,0x80, 0x00,0x00,0x00,0x00, 0x03,0x04,0x08,0x08, 0x00,0x00,0x00,0x00, 0xE0,0x10,0x08,0x08, 0x08,0x08,0x08,0x04, 0x03,0x00,0x00,0x00, 0x08,0x08,0x08,0x10, 0xE0,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x55, 0x00,0x00,0x00,0x00, 0x00,0x00,0xAA,0x55, 0x00,0x00,0x00,0x00, 0x00,0x55,0xAA,0x55, 0x00,0x00,0x00,0x00, 0xAA,0x55,0xAA,0x55, 0x00,0x00,0x00,0x55, 0xAA,0x55,0xAA,0x55, 0x00,0x00,0xAA,0x55, 0xAA,0x55,0xAA,0x55, 0x00,0x55,0xAA,0x55, 0xAA,0x55,0xAA,0x55, 0xAA,0x55,0xAA,0x55, 0xAA,0x55,0xAA,0x55, 0xAA,0x55,0xAA,0x55, 0xAA,0x55,0xAA,0x00, 0xAA,0x55,0xAA,0x55, 0xAA,0x55,0x00,0x00, 0xAA,0x55,0xAA,0x55, 0xAA,0x00,0x00,0x00, 0xAA,0x55,0xAA,0x55, 0x00,0x00,0x00,0x00, 0xAA,0x55,0xAA,0x00, 0x00,0x00,0x00,0x00, 0xAA,0x55,0x00,0x00, 0x00,0x00,0x00,0x00, 0xAA,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x80,0x00,0x80,0x00, 0x80,0x00,0x80,0x00, 0x80,0x40,0x80,0x40, 0x80,0x40,0x80,0x40, 0xA0,0x40,0xA0,0x40, 0xA0,0x40,0xA0,0x40, 0xA0,0x50,0xA0,0x50, 0xA0,0x50,0xA0,0x50, 0xA8,0x50,0xA8,0x50, 0xA8,0x50,0xA8,0x50, 0xA8,0x54,0xA8,0x54, 0xA8,0x54,0xA8,0x54, 0xAA,0x54,0xAA,0x54, 0xAA,0x54,0xAA,0x54, 0x2A,0x55,0x2A,0x55, 0x2A,0x55,0x2A,0x55, 0x7E,0x81,0x9D,0xA1, 0xA1,0x9D,0x81,0x7E, 0x2A,0x15,0x2A,0x15, 0x2A,0x15,0x2A,0x15, 0x0A,0x15,0x0A,0x15, 0x0A,0x15,0x0A,0x15, 0x0A,0x05,0x0A,0x05, 0x0A,0x05,0x0A,0x05, 0x02,0x05,0x02,0x05, 0x02,0x05,0x02,0x05, 0x02,0x01,0x02,0x01, 0x02,0x01,0x02,0x01, 0x00,0x01,0x00,0x01, 0x00,0x01,0x00,0x01, 0x00,0x00,0x03,0x06, 0x6C,0x38,0x10,0x00, 0x7E,0x81,0xBD,0xA1, 0xB9,0xA1,0xA1,0x7E, 0x00,0x00,0x3C,0x3C, 0x3C,0x3C,0x00,0x00, 0x00,0x3C,0x42,0x5A, 0x5A,0x42,0x3C,0x00, 0x00,0x00,0x18,0x3C, 0x3C,0x18,0x00,0x00, 0xFF,0x81,0x81,0x81, 0x81,0x81,0x81,0xFF, 0x01,0x03,0x07,0x0F, 0x1F,0x3F,0x7F,0xFF, 0x80,0xC0,0xE0,0xF0, 0xF8,0xFC,0xFE,0xFF, 0x3F,0x1F,0x0F,0x07, 0x03,0x01,0x00,0x00, 0xFC,0xF8,0xF0,0xE0, 0xC0,0x80,0x00,0x00, 0x00,0x00,0x01,0x03, 0x07,0x0F,0x1F,0x3F, 0x00,0x00,0x80,0xC0, 0xE0,0xF0,0xF8,0xFC, 0x0F,0x07,0x03,0x01, 0x00,0x00,0x00,0x00, 0xF0,0xE0,0xC0,0x80, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x01,0x03,0x07,0x0F, 0x00,0x00,0x00,0x00, 0x80,0xC0,0xE0,0xF0, 0x03,0x01,0x00,0x00, 0x00,0x00,0x00,0x00, 0xC0,0x80,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x01,0x03, 0x00,0x00,0x00,0x00, 0x00,0x00,0x80,0xC0, 0x00,0x00,0x00,0x00, 0x0F,0x0F,0x0F,0x0F, 0x00,0x00,0x00,0x00, 0xF0,0xF0,0xF0,0xF0, 0x0F,0x0F,0x0F,0x0F, 0x00,0x00,0x00,0x00, 0xF0,0xF0,0xF0,0xF0, 0x00,0x00,0x00,0x00, 0xF0,0xF0,0xF0,0xF0, 0x0F,0x0F,0x0F,0x0F, 0x0F,0x0F,0x0F,0x0F, 0xF0,0xF0,0xF0,0xF0, 0x00,0x00,0x00,0x3E, 0x1C,0x08,0x00,0x00, 0x00,0x00,0x08,0x18, 0x38,0x18,0x08,0x00, 0x00,0x00,0x10,0x18, 0x1C,0x18,0x10,0x00, 0x00,0x00,0x08,0x1C, 0x3E,0x00,0x00,0x00, 0x6C,0xFE,0xFE,0xFE, 0x7C,0x38,0x10,0x00, 0x00,0x0E,0x12,0x22, 0x44,0x88,0x50,0x20, 0xFE,0x82,0x92,0xBA, 0xBA,0xBA,0x82,0xFE, 0x54,0x92,0xBA,0xC6, 0xC6,0xBA,0x82,0x44,
};


// aseprite says these 154 colors are the google games palette. rearranged for Foenix order.
uint8_t infest_clut[] =
{
0x00,0x00,0x00,0x00, 0x60,0x6c,0xf3,0x00, 0x40,0x4e,0xe8,0x00, 0x23,0x1c,0xe5,0x00, 0x1d,0x19,0xdd,0x00, 0x16,0x17,0xd0,0x00, 
0x11,0x14,0xc4,0x00, 0x0a,0x12,0xb0,0x00, 0xb1,0x8f,0xf4,0x00, 0x92,0x62,0xf0,0x00, 0x7a,0x40,0xec,0x00, 0x63,0x1e,0xe9,0x00, 
0x60,0x1b,0xd8,0x00, 0x5b,0x18,0xc2,0x00, 0x57,0x14,0xad,0x00, 0x4f,0x0e,0x88,0x00, 0xd8,0x93,0xce,0x00, 0xc8,0x68,0xba,0x00, 
0xbc,0x47,0xab,0x00, 0xb0,0x27,0x9c,0x00, 0xaa,0x24,0x8e,0x00, 0xa2,0x1f,0x7b,0x00, 0x9a,0x1b,0x6a,0x00, 0x8c,0x14,0x4a,0x00, 
0xdb,0x9d,0xb3,0x00, 0xcd,0x75,0x95,0x00, 0xc2,0x57,0x7e,0x00, 0xb7,0x3a,0x67,0x00, 0xb1,0x35,0x5e,0x00, 0xa8,0x2d,0x51,0x00, 
0xa0,0x27,0x45,0x00, 0x92,0x1b,0x31,0x00, 0xda,0xa8,0x9f,0x00, 0xcb,0x86,0x79,0x00, 0xc0,0x6b,0x5c,0x00, 0xb5,0x51,0x3f,0x00, 
0xab,0x49,0x39,0x00, 0x9f,0x3f,0x30,0x00, 0x93,0x35,0x28,0x00, 0x7e,0x23,0x1a,0x00, 0xff,0xbf,0xaf,0x00, 0xff,0xa7,0x91,0x00, 
0xfe,0x8f,0x73,0x00, 0xfc,0x77,0x56,0x00, 0xef,0x6c,0x4e,0x00, 0xde,0x5e,0x45,0x00, 0xce,0x50,0x3b,0x00, 0xb1,0x36,0x2a,0x00, 
0xfa,0xd4,0x81,0x00, 0xf7,0xc3,0x4f,0x00, 0xf6,0xb6,0x29,0x00, 0xf4,0xa9,0x03,0x00, 0xe5,0x9b,0x03,0x00, 0xd1,0x88,0x02,0x00, 
0xbd,0x77,0x02,0x00, 0x9b,0x57,0x01,0x00, 0xea,0xde,0x80,0x00, 0xe1,0xd0,0x4d,0x00, 0xda,0xc6,0x26,0x00, 0xd4,0xbc,0x00,0x00, 
0xc1,0xac,0x00,0x00, 0xa7,0x97,0x00,0x00, 0x8f,0x83,0x00,0x00, 0x64,0x60,0x00,0x00, 0xc4,0xcb,0x80,0x00, 0xac,0xb6,0x4d,0x00, 
0x9a,0xa6,0x26,0x00, 0x88,0x96,0x00,0x00, 0x7b,0x89,0x00,0x00, 0x6b,0x79,0x00,0x00, 0x5c,0x69,0x00,0x00, 0x40,0x4d,0x00,0x00, 
0x72,0xd5,0x72,0x00, 0x41,0xbd,0x42,0x00, 0x2b,0xaf,0x2b,0x00, 0x24,0x9b,0x25,0x00, 0x08,0x8f,0x0a,0x00, 0x07,0x7e,0x0a,0x00, 
0x00,0x6f,0x05,0x00, 0x02,0x53,0x0d,0x00, 0xa5,0xe1,0xc5,0x00, 0x81,0xd5,0xae,0x00, 0x65,0xcc,0x9c,0x00, 0x4a,0xc3,0x8b,0x00, 
0x42,0xb3,0x7c,0x00, 0x38,0x9f,0x68,0x00, 0x2f,0x8b,0x55,0x00, 0x1e,0x69,0x33,0x00, 0x9c,0xee,0xe6,0x00, 0x75,0xe7,0xdc,0x00, 
0x57,0xe1,0xd4,0x00, 0x39,0xdc,0xcd,0x00, 0x33,0xca,0xc0,0x00, 0x2b,0xb4,0xaf,0x00, 0x24,0x9d,0x9e,0x00, 0x17,0x77,0x82,0x00, 
0x9d,0xf5,0xff,0x00, 0x76,0xf1,0xff,0x00, 0x58,0xee,0xff,0x00, 0x3b,0xeb,0xff,0x00, 0x35,0xd8,0xfd,0x00, 0x2d,0xc0,0xfb,0x00, 
0x25,0xa8,0xf9,0x00, 0x17,0x7f,0xf5,0x00, 0x82,0xe0,0xff,0x00, 0x4f,0xd5,0xff,0x00, 0x28,0xca,0xff,0x00, 0x07,0xc1,0xff,0x00, 
0x00,0xb3,0xff,0x00, 0x00,0xa0,0xff,0x00, 0x00,0x8f,0xff,0x00, 0x00,0x6f,0xff,0x00, 0x80,0xcc,0xff,0x00, 0x4d,0xb7,0xff,0x00, 
0x26,0xa7,0xff,0x00, 0x00,0x98,0xff,0x00, 0x00,0x8c,0xfb,0x00, 0x00,0x7c,0xf5,0x00, 0x00,0x6c,0xef,0x00, 0x00,0x51,0xe6,0x00, 
0x91,0xab,0xff,0x00, 0x65,0x8a,0xff,0x00, 0x43,0x70,0xff,0x00, 0x22,0x57,0xff,0x00, 0x1e,0x51,0xf4,0x00, 0x19,0x4a,0xe6,0x00, 
0x15,0x43,0xd8,0x00, 0x0c,0x36,0xbf,0x00, 0xa4,0xaa,0xbc,0x00, 0x7f,0x88,0xa1,0x00, 0x63,0x6e,0x8d,0x00, 0x48,0x55,0x79,0x00, 
0x41,0x4c,0x6d,0x00, 0x37,0x40,0x5d,0x00, 0x2e,0x34,0x4e,0x00, 0x23,0x27,0x3e,0x00, 0xee,0xee,0xee,0x00, 0xe0,0xe0,0xe0,0x00, 
0xbd,0xbd,0xbd,0x00, 0x9e,0x9e,0x9e,0x00, 0x75,0x75,0x75,0x00, 0x61,0x61,0x61,0x00, 0x42,0x42,0x42,0x00, 0x21,0x21,0x21,0x00, 
0xc5,0xbe,0xb0,0x00, 0xae,0xa4,0x90,0x00, 0x9c,0x90,0x78,0x00, 0x8b,0x7d,0x60,0x00, 0x7a,0x6e,0x54,0x00, 0x64,0x5a,0x45,0x00, 
0x4f,0x47,0x37,0x00, 0x38,0x32,0x26,0x00, 0x00,0x00,0x00,0x00, 0xff,0xff,0xff,0x00, };


// F256JR/K colors, used for both fore- and background colors in Text mode
// in C256 & F256, these are 8 bit values; in A2560s, they are 32 bit values, and endianness matters
static uint8_t standard_text_color_lut[64] = 
{
	0x00, 0x00, 0x00, 0x00,
	0x66, 0x66, 0x66, 0x00,
	0xAA, 0x00, 0x00, 0x00,
	0x00, 0xAA, 0x00, 0x00,
	0xEA, 0x41, 0xC0, 0x00,
	0x00, 0x48, 0x87, 0x00,
	0x00, 0x9C, 0xFF, 0x00,
	0xFF, 0xDB, 0x57, 0x00,
	0x28, 0x3F, 0x3F, 0x00,
	0x8A, 0xAA, 0xAA, 0x00,
	0xFF, 0x55, 0x55, 0x00,
	0x55, 0xFF, 0x55, 0x00,
	0xED, 0x8D, 0xFF, 0x00,
	0x00, 0x00, 0xFF, 0x00,			
	0x55, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0x00
};




/*****************************************************************************/
/*                             Global Variables                              */
/*****************************************************************************/

static System	system_storage;
System*			global_system = &system_storage;

extern Player*				global_player;


extern char*				global_string[NUM_STRINGS];
extern char*				global_string_buff1;
// extern char*				global_string_buff2;

extern char					global_comm_buff[COMM_BUFF_SIZE];
extern char**				global_comm_buffer_line[COMM_BUFFER_NUM_ROWS];	// ptp for the comms buffer rows, to allow scrolling
extern uint8_t				global_curr_buff_row;
extern char*				global_comm_buffer[COMM_BUFFER_NUM_ROWS];

extern Sprite				global_missiles[LEVEL_MAX_MISSILES];
extern Sprite				global_humans[LEVEL_MAX_HUMANS];
extern Sprite				global_chips[LEVEL_MAX_CHIPS];
extern Sprite				global_clips[LEVEL_MAX_CLIPS];
extern Sprite				global_poo[LEVEL_MAX_POO];

extern uint8_t				zp_bank_num;
extern uint8_t				io_bank_value_kernel;	// stores value for the physical bank pointing to C000-DFFF whenever we change it, so we can restore it.

#pragma zpsym ("zp_bank_num");

extern uint16_t				zp_px;
extern uint16_t				zp_py;
extern uint8_t				zp_num_bullets;
extern uint8_t				zp_num_clips;
extern uint8_t				zp_num_warps;
extern uint8_t				zp_speed;
extern uint16_t				zp_points;
extern int8_t				zp_hp;
extern uint8_t				zp_bullet_dmg;
extern uint8_t				zp_player_dir;
extern int8_t				zp_lives;

#pragma zpsym ("zp_px");
#pragma zpsym ("zp_py");
#pragma zpsym ("zp_num_bullets");
#pragma zpsym ("zp_num_clips");
#pragma zpsym ("zp_num_warps");
#pragma zpsym ("zp_speed");
#pragma zpsym ("zp_points");
#pragma zpsym ("zp_hp");
#pragma zpsym ("zp_bullet_dmg");
#pragma zpsym ("zp_player_dir");
#pragma zpsym ("zp_lives");

/*****************************************************************************/
/*                       Private Function Prototypes                         */
/*****************************************************************************/

// enable or disable the gamma correction 
void Sys_SetGammaMode(bool enable_it);

// enable or disable double height/width pixels
void Sys_SetFatPixels(bool enable_it);

//! Switch machine into text mode
//! @param as_overlay: If true, sets text overlay mode (text over graphics). If false, sets full text mode (no graphics);
void Sys_SetModeText(bool as_overlay);

//! Switch machine into graphics mode, text mode, sprite mode, etc.
//! Use PARAM_SPRITES_ON/OFF, PARAM_BITMAP_ON/OFF, PARAM_TILES_ON/OFF, PARAM_TEXT_OVERLAY_ON/OFF, PARAM_TEXT_ON/OFF
void Sys_SetGraphicMode(bool enable_sprites, bool enable_bitmaps, bool enable_tiles, bool enable_text_overlay, bool enable_text);

// display machine info: F256JR or F256K
void Startup_ShowMachineSplash(void);

// Set logo palette, display Foenix logo on screen, display basic about info
// does NOT clear the screen first
void Startup_ShowFoenixLogo(void);

// display information about f/manager, the machine, and the MicroKernel
void Startup_ShowAboutInfo(void);

// load in game font
void LoadCustomFont(void);


/*****************************************************************************/
/*                       Private Function Definitions                        */
/*****************************************************************************/

// enable or disable the gamma correction 
void Sys_SetGammaMode(bool enable_it)
{
	uint8_t		the_gamma_mode_bits = R8(VICKY_GAMMA_CTRL_REG);
	uint8_t		new_mode_flag;

	// LOGIC:
	//   both C256s and A2560s have a gamma correction mode
	//   It needs to be hardware enabled by turning DIP switch 7 on the motherboard to ON (I believe)
	//     bit 5 (0x20) of the video mode byte in vicky master control reflects the DIP switch setting, but doesn't change anything if you write to it 
	//   byte 3 of the vicky master control appears to be dedicated to Gamma correction, but not all bits are documented. Stay away from all but the first 2!
	//     gamma correction can be activated by setting the first and 2nd bits of byte 3
	
	if (enable_it)
	{
		new_mode_flag = 0xFF;
	}
	else
	{
		new_mode_flag = 0x00;
	}

	Sys_SwapIOPage(VICKY_IO_PAGE_REGISTERS);
	
	//DEBUG_OUT(("%s %d: vicky byte 3 before gamma change = %x", __func__, __LINE__, the_gamma_mode_bits));
	the_gamma_mode_bits |= (GAMMA_MODE_ONOFF_BITS & new_mode_flag);
	R8(VICKY_GAMMA_CTRL_REG) = the_gamma_mode_bits;
	//DEBUG_OUT(("%s %d: vicky byte 3 after gamma change = %x, %x", __func__, __LINE__, the_gamma_mode_bits, R8(VICKY_GAMMA_CTRL_REG)));
	//DEBUG_OUT(("%s %d: wrote to %x to register at %p", __func__, __LINE__, the_gamma_mode_bits, P8(VICKY_GAMMA_CTRL_REG)));
	
	Sys_RestoreIOPage();
}





/*****************************************************************************/
/*                        Public Function Definitions                        */
/*****************************************************************************/


//! Initialize the system (primary entry point for all system initialization activity)
//! Starts up the memory manager, creates the global system object, runs autoconfigure to check the system hardware, loads system and application fonts, allocates a bitmap for the screen.
bool Sys_InitSystem(void)
{	
	// open log file, if on real hardware, and built with calypsi, and debugging flags were passed
	#if defined LOG_LEVEL_1 || defined LOG_LEVEL_2 || defined LOG_LEVEL_3 || defined LOG_LEVEL_4 || defined LOG_LEVEL_5
		if (General_LogInitialize() == false)
		{
			printf("%s %d: failed to open log file for writing \n", __func__, __LINE__);
		}
	#endif
	
	//DEBUG_OUT(("%s %d: Initializing System...", __func__, __LINE__));
	
	// check what kind of hardware the system is running on
	// LOGIC: we need to know how many screens it has before allocating screen objects
	if (Sys_AutoDetectMachine() == false)
	{
		LOG_ERR(("%s %d: Detected machine hardware is incompatible with this software", __func__ , __LINE__));
		return false;
	}
	
	//DEBUG_OUT(("%s %d: Hardware detected. Running Autoconfigure...", __func__, __LINE__));
	
	if (Sys_AutoConfigure() == false)
	{
		LOG_ERR(("%s %d: Auto configure failed", __func__, __LINE__));
		return false;
	}

	// clear 0x0200, 0201, 0202, and 0203 to make next start after reset more accurate
	// (if started from flash, then from disk, then reset, the "- fm" would still be in memory otherwise)
	memset((char*)0x0200, 0, 4);

	// set to 320x240 mode
	Sys_SetFatPixels(true);
	
	// load font
	LoadCustomFont();
	
	// Enable mouse pointer -- no idea if this works, f68 emulator doesn't support mouse yet. 
	//R32(VICKYB_MOUSE_CTRL_A2560K) = 1;
	
	// set interrupt handlers
//	ps2_init();
//	global_old_keyboard_interrupt = sys_int_register(INT_KBD_PS2, &Sys_InterruptKeyboard);
// 	global_old_keyboard_interrupt = sys_int_register(INT_KBD_A2560K, &Sys_InterruptKeyboard);
// 	global_old_mouse_interrupt = sys_int_register(INT_MOUSE, &Sys_InterruptKeyboard);

	//DEBUG_OUT(("%s %d: System initialization complete.", __func__, __LINE__));

	return true;
}


//! Find out what kind of machine the software is running on, and determine # of screens available
//! @param	the_system: valid pointer to system object
//! @return	Returns false if the machine is known to be incompatible with this software. 
bool Sys_AutoDetectMachine(void)
{
	uint8_t	the_machine_id;
	
	Sys_SwapIOPage(VICKY_IO_PAGE_REGISTERS);
	
	the_machine_id = (R8(MACHINE_ID_REGISTER) & MACHINE_MODEL_MASK);	
	
	Sys_RestoreIOPage();

	global_system->model_number_ = the_machine_id;
// 	DEBUG_OUT(("%s %d: global_system->model_number_=%u", __func__, __LINE__, global_system->model_number_));
	
	return true;
}


//! Find out what kind of machine the software is running on, and configure the passed screen accordingly
//! Configures screen settings, RAM addresses, etc. based on known info about machine types
//! Configures screen width, height, total text rows and cols, and visible text rows and cols by checking hardware
//! @param	the_system: valid pointer to system object
//! @return	Returns false if the machine is known to be incompatible with this software. 
bool Sys_AutoConfigure(void)
{
// 	sprintf(global_string_buff1, "global_system->model_number_=%u", global_system->model_number_);
// 	Buffer_NewMessage(global_string_buff1);
// 	General_DelayTicks(40000);

	if (global_system->model_number_ == MACHINE_F256_JR || global_system->model_number_ == MACHINE_F256K)
	{
		//DEBUG_OUT(("%s %d: Configuring screens for an F256jr (1 screen)", __func__, __LINE__));
// 		global_system->screen_[ID_CHANNEL_A]->vicky_ = P32(VICKY_C256);
// 		global_system->screen_[ID_CHANNEL_A]->text_ram_ = TEXT_RAM_C256;
// 		global_system->screen_[ID_CHANNEL_A]->text_attr_ram_ = TEXT_ATTR_C256;
// 		global_system->screen_[ID_CHANNEL_A]->text_font_ram_ = FONT_MEMORY_BANK_C256;
// 		global_system->screen_[ID_CHANNEL_A]->text_color_fore_ram_ = (char*)TEXT_FORE_LUT_C256;
// 		global_system->screen_[ID_CHANNEL_A]->text_color_back_ram_ = (char*)TEXT_BACK_LUT_C256;
	
		// use auto configure to set resolution, text cols, margins, etc
		if (Sys_DetectScreenSize() == false)
		{
			LOG_ERR(("%s %d: Unable to auto-configure screen resolution", __func__, __LINE__));
			return false;
		}

		Sys_SwapIOPage(VICKY_IO_PAGE_REGISTERS);
	
		// set standard color LUTs for text mode
		memcpy((uint8_t*)(TEXT_FORE_LUT), &standard_text_color_lut, 64);
		memcpy((uint8_t*)(TEXT_BACK_LUT), &standard_text_color_lut, 64);
	
		Sys_RestoreIOPage();
	
// 		DEBUG_OUT(("%s %d: This screen has %i x %i text (%i x %i visible)", __func__, __LINE__, 
// 			global_system->text_mem_cols_, 
// 			global_system->text_mem_rows_, 
// 			global_system->text_cols_vis_, 
// 			global_system->text_rows_vis_
// 			));
	}
	else
	{
		//DEBUG_OUT(("%s %d: this system %i not supported!", __func__, __LINE__, global_system->model_number_));
		return false;
	}
		
	// always enable gamma correction
	Sys_SetGammaMode(true);
	
	return true;
}


// enable or disable double height/width pixels
void Sys_SetFatPixels(bool enable_it)
{
	Sys_SwapIOPage(VICKY_IO_PAGE_REGISTERS);

	if (enable_it)
	{
		R8(VICKY_MASTER_CTRL_REG_H) = (VICKY_RES_FON_SET | VICKY_RES_Y_DOUBLER_FLAG | VICKY_RES_X_DOUBLER_FLAG);
	}
	else
	{
		R8(VICKY_MASTER_CTRL_REG_H) = (VICKY_RES_FON_SET);
	}
	
	Sys_RestoreIOPage();
}


//! Switch machine into graphics mode, text mode, sprite mode, etc.
//! Use PARAM_SPRITES_ON/OFF, PARAM_BITMAP_ON/OFF, PARAM_TILES_ON/OFF, PARAM_TEXT_OVERLAY_ON/OFF, PARAM_TEXT_ON/OFF
void Sys_SetGraphicMode(bool enable_sprites, bool enable_bitmaps, bool enable_tiles, bool enable_text_overlay, bool enable_text)
{	
	uint8_t		the_bits;
	
	// LOGIC:
	//   clears everything but the gamma mode
	//   then re-enables only those modes specified

	// need to have vicky registers available
	Sys_SwapIOPage(VICKY_IO_PAGE_REGISTERS);

	the_bits = R8(VICKY_MASTER_CTRL_REG_L) & GAMMA_MODE_ONOFF_BITS;	

	if (enable_sprites | enable_bitmaps | enable_tiles | enable_text_overlay)
	{
		the_bits |= GRAPHICS_MODE_GRAPHICS;
	}
	
	if (enable_sprites)
	{
		the_bits |= GRAPHICS_MODE_EN_SPRITE;
	}

	if (enable_bitmaps)
	{
		the_bits |= GRAPHICS_MODE_EN_BITMAP;
		// enable bitmap layers 0, 1; disable layer 2
		R8(VICKY_LAYER_CTRL_1) = 0xFF;
		R8(VICKY_LAYER_CTRL_2) = 0x00;
	}

	if (enable_tiles)
	{
		the_bits |= GRAPHICS_MODE_EN_TILE;
	}

	if (enable_text)
	{
		the_bits |= GRAPHICS_MODE_TEXT;
		// disable bitmap layers 0, 1, 2
		R8(VICKY_LAYER_CTRL_1) = 0x00;
		R8(VICKY_LAYER_CTRL_2) = 0x00;
	}

	if (enable_text_overlay)
	{
		the_bits |= GRAPHICS_MODE_TEXT;
		the_bits |= GRAPHICS_MODE_TEXT_OVER;
		the_bits |= GRAPHICS_MODE_GRAPHICS;
	}

	// switch to graphics mode by setting graphics mode bit, and setting bitmap engine enable bit
	R8(VICKY_MASTER_CTRL_REG_L) = (the_bits);

	Sys_DisableIOBank();
	
	return;
}


//! Switch machine into text mode
//! @param as_overlay: If true, sets text overlay mode (text over graphics). If false, sets full text mode (no graphics);
void Sys_SetModeText(bool as_overlay)
{	
	// LOGIC:
	//   

	Sys_SetGraphicMode(as_overlay, as_overlay, as_overlay, as_overlay, !as_overlay);
	
// 	if (as_overlay)
// 	{
// 		
// 		// switch to text mode with overlay by setting graphics mode bit, setting bitmap engine enable bit, and setting graphics mode overlay		
// 		R8(VICKY_MASTER_CTRL_REG_L) = (GRAPHICS_MODE_TEXT | GRAPHICS_MODE_TEXT_OVER | GRAPHICS_MODE_GRAPHICS | GRAPHICS_MODE_EN_SPRITE | GRAPHICS_MODE_EN_BITMAP);
// 		// enable bitmap layers 0, 1; disable layer 2
// 		R8(VICKY_LAYER_CTRL_1) = 0xFF;
// 		R8(VICKY_LAYER_CTRL_2) = 0x00;
// 		
// 		// c256foenix, discord 2022/03/10
// 		// Normally, for example, if you setup everything to be in bitmap mode, and you download an image in VRAM and you can see it properly... If you turn on overlay, then you will see on top of that same image, your text that you had before.
// 		// Mstr_Ctrl_Text_Mode_En  = $01       ; Enable the Text Mode
// 		// Mstr_Ctrl_Text_Overlay  = $02       ; Enable the Overlay of the text mode on top of Graphic Mode (the Background Color is ignored)
// 		// Mstr_Ctrl_Graph_Mode_En = $04       ; Enable the Graphic Mode
// 		// Mstr_Ctrl_Bitmap_En     = $08       ; Enable the Bitmap Module In Vicky
// 		// all of these should be ON
// 	}
// 	else
// 	{
// 		R8(VICKY_MASTER_CTRL_REG_L) = (GRAPHICS_MODE_TEXT);
// 		// disable bitmap layers 0, 1, and 2
// 		R8(VICKY_LAYER_CTRL_1) = 0x00;
// 		R8(VICKY_LAYER_CTRL_2) = 0x00;
// 	}
	
	return;
}


// load in game font
void LoadCustomFont(void)
{	
	Sys_SwapIOPage(VICKY_IO_PAGE_FONT_AND_LUTS);

	memcpy((uint8_t*)FONT_MEMORY_BANK1, custom_font_data, (8*256));
		
	Sys_RestoreIOPage();
}


//! Detect the current screen mode/resolution, and set # of columns, rows, H pixels, V pixels, accordingly
bool Sys_DetectScreenSize(void)
{
	//uint8_t			new_mode;
	uint8_t			the_video_mode_bits;
	uint8_t			border_x_cols;
	uint8_t			border_y_cols;
	int16_t			border_x_pixels;
	int16_t			border_y_pixels;
	
	// detect the video mode and set resolution based on it
	
	Sys_SwapIOPage(VICKY_IO_PAGE_REGISTERS);

	the_video_mode_bits = R8(VICKY_MASTER_CTRL_REG_H);
	//DEBUG_OUT(("%s %d: 8bit vicky ptr 2nd byte=%p, video mode bits=%x", __func__, __LINE__, vicky_8bit_ptr, the_video_mode_bits));
	
	//   F256JR has 1 channel with 2 video modes, 70hz=640x400 (graphics doubled to 320x200) and 60hz=640x480

	if (the_video_mode_bits & VIDEO_MODE_FREQ_BIT)
	{
		//new_mode = RES_320X200;
		global_system->text_mem_rows_ = TEXT_ROW_COUNT_70HZ; // 2 options in JR. the_screen->height_ / TEXT_FONT_HEIGHT;
	}
	else
	{
		//new_mode = RES_320X240;
		global_system->text_mem_rows_ = TEXT_ROW_COUNT_60HZ; // 2 options in JR. the_screen->height_ / TEXT_FONT_HEIGHT;
	}

// we don't really care about pixels in this app... 
// 	switch (new_mode)
// 	{
// 		case RES_320X200:
// 			the_screen->width_ = 320;	
// 			the_screen->height_ = 200;
// 			DEBUG_OUT(("%s %d: set to RES_320X200", __func__, __LINE__));
// 			break;
// 			
// 		case RES_320X240:
// 			the_screen->width_ = 320;	
// 			the_screen->height_ = 240;
// 			DEBUG_OUT(("%s %d: set to RES_320X200", __func__, __LINE__));
// 			break;
// 	}
	
	// detect borders, and set text cols/rows based on resolution modified by borders (if any)
	border_x_pixels = R8(VICKY_BORDER_X_SIZE);
	border_y_pixels = R8(VICKY_BORDER_Y_SIZE);
	//DEBUG_OUT(("%s %d: border x,y=%i,%i", __func__, __LINE__, R8(VICKY_BORDER_X_SIZE), R8(VICKY_BORDER_Y_SIZE)));
	
	Sys_RestoreIOPage();
	
	border_x_cols = (border_x_pixels * 2) / TEXT_FONT_WIDTH;
	border_y_cols = (border_y_pixels * 2) / TEXT_FONT_HEIGHT;
	global_system->text_mem_cols_ = TEXT_COL_COUNT_FOR_PLOTTING; // only 1 option in JR. the_screen->width_ / TEXT_FONT_WIDTH;
	global_system->text_cols_vis_ = global_system->text_mem_cols_ - border_x_cols;
	global_system->text_rows_vis_ = global_system->text_mem_rows_ - border_y_cols;
// 	global_system->rect_.MaxX = the_screen->width_;
// 	global_system->rect_.MaxY = the_screen->height_;	
	//Sys_PrintScreen(the_screen);
	
	return true;
}


//! Set the left/right and top/bottom borders
//! This will reset the visible text columns as a side effect
//! Grotesquely large values will be accepted as is: use at your own risk!
//! @param	border_width: width in pixels of the border on left and right side of the screen. Total border used with be the double of this.
//! @param	border_height: height in pixels of the border on top and bottom of the screen. Total border used with be the double of this.
//! @return	returns false on any error/invalid input.
void Sys_SetBorderSize(uint8_t border_width, uint8_t border_height)
{
	uint8_t		border_x_cols;
	uint8_t		border_y_cols;

	// LOGIC: 
	//   borders are set in pixels, from 0 to 31 max. 
	//   borders have no effect unless the border is enabled!
	
	Sys_SwapIOPage(VICKY_IO_PAGE_REGISTERS);
	
	// set borders
	R8(VICKY_BORDER_X_SIZE) = border_width;
	R8(VICKY_BORDER_Y_SIZE) = border_height;
	
	// enable borders or disable
	if (border_width > 0 || border_height > 0)
	{
		R8(VICKY_BORDER_CTRL_REG) = 1;
	}
	else
	{
		R8(VICKY_BORDER_CTRL_REG) = 0;
	}
	
	Sys_RestoreIOPage();

	border_x_cols = (border_width * 2) / TEXT_FONT_WIDTH;
	border_y_cols = (border_height * 2) / TEXT_FONT_HEIGHT;
	//DEBUG_OUT(("%s %d: x and y borders set to %u, %u", __func__, __LINE__, border_width, border_height));
	//DEBUG_OUT(("%s %d: x and y borders cols/rows now %u, %u", __func__, __LINE__, border_x_cols, border_y_cols));
	
	// now we need to recalculate how many text cols/rows are visible, because it might have changed
	global_system->text_cols_vis_ = global_system->text_mem_cols_ - border_x_cols;
	global_system->text_rows_vis_ = global_system->text_mem_rows_ - border_y_cols;
	//DEBUG_OUT(("%s %d: visible cols,rows now %u, %u", __func__, __LINE__, global_system->text_cols_vis_, global_system->text_rows_vis_));
}



// enable the random number generator, and seed it
void Startup_InitializeRandomNumGen(void)
{
	// LOGIC: 
	//   f256jr has a built in random number generator
	//   it works like this:
	//     1) you enable it with bit 0 of RND_CTRL
	//     2) you turn on seed mode by setting bit 1 of RND_CTRL to 1.
	//     3) you populate RNDL and RNDH with a seed
	//     4) you turn off see mode by unsetting bit 1 of RND_CTRL.
	//     5) you get random numbers by reading RNDL and RNDH. every time you read them, it repopulates them. 
	//     6) resulting 16 bit number you divide by 65336 (RAND_MAX_FOENIX) to get a number 0-1. 
	//   I will use the real time clock to seed the number generator
	
	uint8_t		old_rtc_control;
	
	// need to have vicky registers available
	Sys_SwapIOPage(VICKY_IO_PAGE_REGISTERS);
	
	// get mins and seconds from RTC
	old_rtc_control = R8(RTC_CONTROL);
	R8(RTC_CONTROL) = old_rtc_control | 0x08; // stop it from updating external registers
	
	// seed the RNG with time
	R8(RANDOM_NUM_GEN_ENABLE) = 3; // enable and set seed mode
	R8(RANDOM_NUM_GEN_LOW) = R8(RTC_SECONDS);
	R8(RANDOM_NUM_GEN_HI) = R8(RTC_MINUTES);
	R8(RANDOM_NUM_GEN_ENABLE) = 1; // keep enabled, return to generate mode
	
	// restore timer control to what it had been
	R8(RTC_CONTROL) = old_rtc_control;

	Sys_DisableIOBank();
}


// load sprite LUT and teach VICKY where the graphics  are
void Startup_SetUpSprites(void)
{
	// LOGIC: 
	//   we can set graphics mode, and lot in LUT from overlay
	//   but VICKY needs access to the sprite data but it doesn't have to be in CPU space
	//   we are loading it into EM with the pgZ and pointing VICKY directly at that. 
	
	uint8_t		the_value;

	//DEBUG_OUT(("%s %d: setting graphics mode", __func__, __LINE__));
	
	// enable graphics and sprite engine and overlay text mode; leave tiles off
	Sys_SetGraphicMode(PARAM_SPRITES_ON, PARAM_BITMAP_ON, PARAM_TILES_ON, PARAM_TEXT_OVERLAY_ON, PARAM_TEXT_OFF);
		
	// need to have I/O page for LUTs
	Sys_SwapIOPage(VICKY_IO_PAGE_FONT_AND_LUTS);

	//DEBUG_OUT(("%s %d: loading color LUT", __func__, __LINE__));

	// load the sprite LUT
	memcpy((uint8_t*)VICKY_CLUT0, &infest_clut, 616);

	//DEBUG_OUT(("%s %d: teaching vicky about sprite; sprite_graphic=%p addrLO to %x, MED to %x", __func__, __LINE__, sprite_graphic, (uint16_t)sprite_graphic & 0xFF, (uint16_t)(sprite_graphic) >> 8));

	// tell VICKY where the sprite data is
	Sys_SwapIOPage(VICKY_IO_PAGE_REGISTERS);
	R8(SPRITE0_ADDR_LO) = SPRITE_ROBOT_16F_LO_ADDR;
	R8(SPRITE0_ADDR_MED) = SPRITE_ROBOT_16F_MED_ADDR;
	R8(SPRITE0_ADDR_HI) = SPRITE_ROBOT_16F_HI_ADDR;	// we are placing robot sprites starting at 02 4000 in EM
	
	Sys_DisableIOBank();
}


// Point the VICKY to our tile graphics and the tilemap
void Startup_SetUpTileMap(void)
{
	// LOGIC: 
	//   tile+graphics mode is required, and must be called by another routine, this one doesn't do it.
	//   
	
	uint8_t		the_value;

	//DEBUG_OUT(("%s %d: setting graphics mode", __func__, __LINE__));
	
	Sys_SwapIOPage(VICKY_IO_PAGE_REGISTERS);

	//DEBUG_OUT(("%s %d: setting tilemap 0 to graphic layer 1...", __func__, __LINE__));

	// Assign tilemap 0 to graphic layer 1
	R8(VICKY_LAYER_CTRL_1) = 0x40;		// 0, 1, 2 assign bitmap layers 0-2. 4-6 assign tilemap layers 0-2
	R8(VICKY_LAYER_CTRL_2) = 0x15;		// honestly no idea why doing this other than it's in example in ref manual

	//DEBUG_OUT(("%s %d: teaching vicky about tile set 0 data", __func__, __LINE__));

	// tell VICKY where the tileset 0 data is
	R8(TILESET0_ADDR_LO) = TILESET_LO_ADDR;
	R8(TILESET0_ADDR_MED) = TILESET_MED_ADDR;
	R8(TILESET0_ADDR_HI) = TILESET_HI_ADDR;		// our tileset graphics start at 02 6000 in EM
	
	// tell VICKY about tilemap: size, shape, and where mapped in EM
	R8(TILE0_CTRL) = 0x01;	// enable; 16x16 tiles
	R8(TILE0_CTRL + TILE_CTRL_OFFSET_MAP_SIZE_X) = 0x14;	// 20 cols of 16 pixels = 320 pixels = matches screen
	R8(TILE0_CTRL + TILE_CTRL_OFFSET_MAP_SIZE_Y) = 0x0f;	// 15 rows of 16 pixels = 240 pixels = matches screen
	// where the tilemap data is stored. our tile MAP starts at 02 5DA8 in EM
	R8(TILE0_CTRL + TILE_CTRL_OFFSET_ADDR_LO) = TILEMAP_LO_ADDR;
	R8(TILE0_CTRL + TILE_CTRL_OFFSET_ADDR_MED) = TILEMAP_MED_ADDR;
	R8(TILE0_CTRL + TILE_CTRL_OFFSET_ADDR_HI) = TILEMAP_HI_ADDR;
	// no vertical or horizontal scrolling wanted
	R8(TILE0_CTRL + TILE_CTRL_OFFSET_SCROLL_X_LO) = 0;
	R8(TILE0_CTRL + TILE_CTRL_OFFSET_SCROLL_X_HI) = 0;
	R8(TILE0_CTRL + TILE_CTRL_OFFSET_SCROLL_Y_LO) = 0;
	R8(TILE0_CTRL + TILE_CTRL_OFFSET_SCROLL_Y_HI) = 0;
	
	Sys_DisableIOBank();
}


// set some player properties at start of game
void Startup_InitializePlayer(void)
{
	// add the player object. 26 bytes.
	global_player = (Player*)STORAGE_PLAYER;
	memset(global_player, 0, sizeof(Player));

	zp_px = 0; // will get set randomly anyway. 
	zp_py = 0;
	zp_points = 0;
	zp_num_bullets = PLAYER_WEAPON_PISTOL_CLIP;	// starting weapon is pistol, so starting bullet count is that of pistol
	zp_num_warps = PLAYER_STARTING_WARP_COUNT;
	zp_speed = PLAYER_NORMAL_MOVES_PER_HALF_TURN;
	zp_hp = global_player->healthy_hp_ = 0;
	zp_lives = PLAYER_STARTING_LIVES;
	zp_player_dir = PLAYER_DIR_EAST; // player graphic starts facing east.
	
	global_player->temp_speed_countdown_ = 0;
	global_player->special_conditions_ = 0;
	
	global_player->clips_[PLAYER_WEAPON_PISTOL] = PLAYER_WEAPON_PISTOL_STARTING_CLIPS;
	global_player->clips_[PLAYER_WEAPON_SUB_MG] = 0;
	global_player->clips_[PLAYER_WEAPON_HEAVY_MG] = 0;
	global_player->clips_[PLAYER_WEAPON_20MM_CANNON] = 0;
	global_player->clips_[PLAYER_WEAPON_FLAMETHROWER] = 0;
	
	// set all bullets-in-clip counters to 0, because this is really "how many bullets are left in the current clip?"
	global_player->bullets_in_clip_[PLAYER_WEAPON_PISTOL] = 0;
	global_player->bullets_in_clip_[PLAYER_WEAPON_SUB_MG] = 0;
	global_player->bullets_in_clip_[PLAYER_WEAPON_HEAVY_MG] = 0;
	global_player->bullets_in_clip_[PLAYER_WEAPON_20MM_CANNON] = 0;
	global_player->bullets_in_clip_[PLAYER_WEAPON_FLAMETHROWER] = 0;
	
	Player_LoseLife();	// uses the first of the lives, converting it to new HP
	Player_SetWeapon(PLAYER_WEAPON_PISTOL);
	
	// tell VICKY where the sprite it, what size sprite it is, what color to use, and to enabled it
	Sys_SwapIOPage(VICKY_IO_PAGE_REGISTERS);
	R16(SPRITE0_X_LO) = zp_px;		
	R16(SPRITE0_Y_LO) = zp_py;		
	R8(SPRITE0_CTRL) = 0x41; //Size=16x16, Layer=0, LUT=0, Enabled	
	Sys_DisableIOBank();
}


// set up all non-player sprites
void Startup_InitializeSprites(void)
{
	uint8_t		i;
	uint8_t*	the_sprite_reg = (uint8_t*)(SPRITE0_CTRL + SPRITE_REG_LEN); // start with first sprite after the player's sprite
	
	for (i=0; i < LEVEL_MAX_HUMANS; i++)
	{
		global_humans[i].state_ = 0x40;	// $40=16x16 sprite; 0 = off
		global_humans[i].addr_lo_ = SPRITE_HUMAN_1_8F_LO_ADDR;
		global_humans[i].addr_med_ = SPRITE_HUMAN_1_8F_MED_ADDR;
		global_humans[i].addr_med_alt_ = SPRITE_HUMAN_1_8F_MED_ADDR + 0x01;	// alt frames are 256b away from base frame
		global_humans[i].addr_hi_ = SPRITE_HUMAN_1_8F_HI_ADDR;
		global_humans[i].addr_base_lomed_ = SPRITE_HUMAN_1_8F_LOMED_ADDR;
		global_humans[i].x1_ = 0;
		global_humans[i].y1_ = 0;
		global_humans[i].x2_ = HUMAN_SPRITE_WIDTH;
		global_humans[i].y2_ = HUMAN_SPRITE_HEIGHT;
		global_humans[i].sprite_reg_addr_ = the_sprite_reg;
		global_humans[i].type_id_ = OBJECT_TYPE_MISSILE;
		global_humans[i].render_needed_ = 0;
		global_humans[i].is_active_ = 0;
		global_humans[i].x_speed_ = 0;
		global_humans[i].y_speed_ = 0;
		global_humans[i].direction_ = PLAYER_DIR_NORTH;
		
		//DEBUG_OUT(("%s %d: human sprite %u configured; reg addr=%p; the_sprite_reg=%p", __func__, __LINE__, i, global_humans[i].sprite_reg_addr_, the_sprite_reg));
		
		the_sprite_reg += SPRITE_REG_LEN;
	}

	for (i=0; i < LEVEL_MAX_MISSILES; i++)
	{
		global_missiles[i].state_ = 0x60;	// $60=8x8 sprite; 0 = off
		global_missiles[i].addr_lo_ = SPRITE_BULLET_S_LO_ADDR;
		global_missiles[i].addr_med_ = SPRITE_BULLET_S_MED_ADDR;
		global_missiles[i].addr_med_alt_ = SPRITE_BULLET_S_MED_ADDR + 0x01;	// alt frames are 256b away from base frame
		global_missiles[i].addr_hi_ = SPRITE_BULLET_S_HI_ADDR;
		global_missiles[i].addr_base_lomed_ = SPRITE_BULLET_S_LOMED_ADDR;
		global_missiles[i].x1_ = 0;
		global_missiles[i].y1_ = 0;
		global_missiles[i].x2_ = MISSILE_SPRITE_WIDTH;
		global_missiles[i].y2_ = MISSILE_SPRITE_HEIGHT;
		global_missiles[i].sprite_reg_addr_ = the_sprite_reg;
		global_missiles[i].type_id_ = OBJECT_TYPE_MISSILE;
		global_missiles[i].render_needed_ = 0;
		global_missiles[i].is_active_ = 0;
		global_missiles[i].x_speed_ = 0;
		global_missiles[i].y_speed_ = 0;
		global_missiles[i].direction_ = PLAYER_DIR_NORTH;
		
		//DEBUG_OUT(("%s %d: missile sprite %u configured; reg addr=%p; the_sprite_reg=%p", __func__, __LINE__, i, global_missiles[i].sprite_reg_addr_, the_sprite_reg));
				
		the_sprite_reg += SPRITE_REG_LEN;
	}
}


// initialize the comms buffer and msg/status area (without drawing anything)
void Startup_InitializeCommsBuffer(void)
{
	uint8_t		i;
	
	//DEBUG_OUT(("%s %d: entered", __func__, __LINE__));

	// set up the comm buffer ptps
	for (i = 0; i < COMM_BUFFER_NUM_ROWS; i++)
	{
		global_comm_buffer[i] = &global_comm_buff[i * (COMM_BUFFER_NUM_COLS + 1)];
		global_comm_buffer_line[i] = &global_comm_buffer[i];
	}
	
	global_curr_buff_row = 0;
}


